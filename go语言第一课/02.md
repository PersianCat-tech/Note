#### go语言的设计哲学
##### 简单
* 仅有25个关键字，主流编程语言最少；
* 内置垃圾收集，降低开发人员内存管理的心智负担；
* 首字母大小写决定可见性，无需通过额外关键字修饰；
* 变量初始为类型零值，避免以随机值作为初值的问题；
* 内置数组边界检查，极大减少越界访问带来的安全隐患；
* 内置并发支持，简化并发程序设计；
* 内置接口类型，为组合的设计哲学奠定基础；
* 原生提供完善的工具链，开箱即用；
##### 显式
先看一段C程序，看看“隐式”代码的行为特征。
```C
#include <stdio.h>

int main() {
		short int a = 5;

		int b = 8;
		long c = 0;
		
		c = a + b;
		printf("%ld\n", c);
}
```
在上面这段代码中，变量a、b和c的类型均不相同，C语言编译器在编译c = a + b这一行时，会自动将短整型变量a和整型变量b，先转换为long类型然后相加，并将所得结果存储在long类型变量c中。
换成Go来实现这个计算会怎么样呢？先把上面的C程序转化成等价的Go代码：
```go
package main

import "fmt"

func main() {
    var a int16 = 5
    var b int = 8
    var c int64

    c = a + b
    fmt.Printf("%d\n", c)
}
```
编译这段程序，将得到类似这样的编译器错误：“invalid operation: a + b (mismatched types int16 and int)”。Go与C语言的隐式自动类型转换不同，Go不允许不同类型的整型变量进行混合计算，它同样也不会对其进行隐式的自动转换。
因此，如果要使这段代码通过编译，我们就需要对变量a和b进行显式转型，就像下面代码段中这样：
```go
c = int64(a) + int64(b)
fmt.Printf("%d\n", c)
```
在Go语言中，不同类型变量是不能在一起进行混合计算的，这是因为Go希望开发人员明确知道自己在做什么，这与C语言的“信任程序员”原则完全不同。
除此之外，Go设计者所崇尚的显式哲学还直接决定了Go语言错误处理的形态：Go语言采用了显式的基于值比较的错误处理方案，函数/方法中的错误都会通过return语句显式地返回，并且通常调用者不能忽略对返回的错误的处理。
##### 组合
* Go语言设计层面，Go设计者为开发者们提供了正交的语法元素，以供后续组合使用，包括：
    * Go语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念；
    * 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；
    * 实现某个接口时，无需像Java那样采用特定关键字修饰；
    * 包之间是相对独立的，没有子包的概念。
##### 并发
CPU都是靠提高主频来改进性能的，但是现在这个做法已经遇到了瓶颈。主频提高导致CPU的功耗和发热量剧增，反过来制约了CPU性能的进一步提高。2007年开始，处理器厂商的竞争焦点从主频转向了多核。
在这种大背景下，Go的设计者在决定去创建一门新语言的时候，果断将面向多核、原生支持并发作为了新语言的设计原则之一。并且，Go放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程，Go将之称为goroutine。
而且，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面上。
##### 面向工程
Go语言设计的初衷，就是面向解决真实世界中Google内部大规模软件开发存在的各种问题，为这些问题提供答案，这些问题包括：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。
在面向工程设计哲学的驱使下，Go在语法设计细节上做了精心的打磨。比如：
* 重新设计编译单元和目标文件格式，实现Go源码快速构建，让大工程的构建时间缩短到类似动态语言的交互式解释的编译速度；
* 如果源文件导入它不使用的包，则程序将无法编译。这可以充分保证任何Go程序的依赖树是精确的。这也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；
* 去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；
* 包路径是唯一的，而包名不必唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的”这个约定，大大降低了开发人员给包起唯一名字的心智负担；
* 故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数API的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；
* 增加类型别名（type alias），支持大规模代码库的重构。